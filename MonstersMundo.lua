require 'DamageLib'  class "HPred"  Callback.Add("Tick", function() HPred:Tick() end)  local _reviveQueryFrequency = 3 local _lastReviveQuery = Game.Timer() local _reviveLookupTable = { ["LifeAura.troy"] = 4, ["ZileanBase_R_Buf.troy"] = 3, ["Aatrox_Base_Passive_Death_Activate"] = 3 }  local _blinkSpellLookupTable = { ["EzrealArcaneShift"] = 475, ["RiftWalk"] = 500, ["EkkoEAttack"] = 0, ["AlphaStrike"] = 0, ["KatarinaE"] = -255, ["KatarinaEDagger"] = { "Katarina_Base_Dagger_Ground_Indicator","Katarina_Skin01_Dagger_Ground_Indicator","Katarina_Skin02_Dagger_Ground_Indicator","Katarina_Skin03_Dagger_Ground_Indicator","Katarina_Skin04_Dagger_Ground_Indicator","Katarina_Skin05_Dagger_Ground_Indicator","Katarina_Skin06_Dagger_Ground_Indicator","Katarina_Skin07_Dagger_Ground_Indicator" ,"Katarina_Skin08_Dagger_Ground_Indicator","Katarina_Skin09_Dagger_Ground_Indicator"  }, }  local _blinkLookupTable = { "global_ss_flash_02.troy", "Lissandra_Base_E_Arrival.troy", "LeBlanc_Base_W_return_activation.troy"  }  local _cachedRevives = {}  local _movementHistory = {}  function HPred:Tick() if Game.Timer() - _lastReviveQuery < _reviveQueryFrequency then return end _lastReviveQuery=Game.Timer()  for _, revive in pairs(_cachedRevives) do if Game.Timer() > revive.expireTime + .5 then _cachedRevives[_] = nil end end  for i = 1, Game.ParticleCount() do local particle = Game.Particle(i) if not _cachedRevives[particle.networkID] and  _reviveLookupTable[particle.name] then _cachedRevives[particle.networkID] = {} _cachedRevives[particle.networkID]["expireTime"] = Game.Timer() + _reviveLookupTable[particle.name] local nearestDistance = 500 for i = 1, Game.HeroCount() do local t = Game.Hero(i) local tDistance = self:GetDistance(particle.pos, t.pos) if tDistance < nearestDistance then nearestDistance = nearestDistance _cachedRevives[particle.networkID]["owner"] = t.charName _cachedRevives[particle.networkID]["pos"] = t.pos _cachedRevives[particle.networkID]["isEnemy"] = t.isEnemy end end end end end  function HPred:GetEnemyNexusPosition() if myHero.team == 100 then return Vector(14340, 171.977722167969, 14390); else return Vector(396,182.132507324219,462); end end   function HPred:GetReliableTarget(source, range, delay, speed, radius, timingAccuracy, checkCollision) local target, aimPosition =self:GetImmobileTarget(source, range, delay, speed, timingAccuracy, checkCollision, radius) if target and aimPosition then return target, aimPosition end  target, aimPosition =self:GetHourglassTarget(source, range, delay, speed, timingAccuracy, checkCollision, radius) if target and aimPosition then return target, aimPosition end  target, aimPosition =self:GetRevivingTarget(source, range, delay, speed, timingAccuracy, checkCollision, radius) if target and aimPosition then return target, aimPosition end  target, aimPosition =self:GetChannelingTarget(source, range, delay, speed, timingAccuracy, checkCollision, radius) if target and aimPosition then return target, aimPosition end  target, aimPosition =self:GetTeleportingTarget(source, range, delay, speed, timingAccuracy, checkCollision, radius) if target and aimPosition then return target, aimPosition end  target, aimPosition =self:GetInstantDashTarget(source, range, delay, speed, timingAccuracy, checkCollision, radius) if target and aimPosition then return target, aimPosition end  target, aimPosition =self:GetDashingTarget(source, range, delay, speed, timingAccuracy, checkCollision, radius, midDash) if target and aimPosition then return target, aimPosition end  target, aimPosition =self:GetBlinkTarget(source, range, speed, delay, checkCollision, radius) if target and aimPosition then return target, aimPosition end end  function HPred:GetLineTargetCount(source, aimPos, delay, speed, width, targetAllies) local targetCount = 0 for i = 1, Game.HeroCount() do local t = Game.Hero(i) if self:CanTargetALL(t) and ( targetAllies or t.isEnemy) then local predictedPos = self:PredictUnitPosition(t, delay+ self:GetDistance(source, t.pos) / speed) if predictedPos:To2D().onScreen then local proj1, pointLine, isOnSegment = self:VectorPointProjectionOnLineSegment(source, aimPos, predictedPos) if proj1 and isOnSegment and (self:GetDistanceSqr(predictedPos, proj1) <= (t.boundingRadius + width) ^ 2) then targetCount = targetCount + 1 end end end end return targetCount end  function HPred:GetUnreliableTarget(source, range, delay, speed, radius, checkCollision, minimumHitChance, whitelist) local _validTargets = {} for i = 1, Game.HeroCount() do local t = Game.Hero(i) if self:CanTarget(t) and (not whitelist or whitelist[t.charName]) then local hitChance, aimPosition = self:GetHitchance(source, t, range, delay, speed, radius, checkCollision) if hitChance >= minimumHitChance and aimPosition:To2D().onScreen then _validTargets[t.charName] = {["hitChance"] = hitChance, ["aimPosition"] = aimPosition} end end end  local rHitChance = 0 local rAimPosition for targetName, targetData in pairs(_validTargets) do if targetData.hitChance > rHitChance then rHitChance = targetData.hitChance rAimPosition = targetData.aimPosition end end  if rHitChance >= minimumHitChance then return rHitChance, rAimPosition end end  function HPred:GetHitchance(source, target, range, delay, speed, radius, checkCollision) self:UpdateMovementHistory(target)  local hitChance = 1  local aimPosition = self:PredictUnitPosition(target, delay + self:GetDistance(source, target.pos) / speed) local interceptTime = self:GetSpellInterceptTime(source, aimPosition, delay, speed) local reactionTime = self:PredictReactionTime(target, .1) local origin,movementRadius = self:UnitMovementBounds(target, interceptTime, reactionTime)  if _movementHistory and _movementHistory[target.charName] and Game.Timer() - _movementHistory[target.charName]["ChangedAt"] < .25 then hitChance = 2 end  if not target.pathing or not target.pathing.hasMovePath then hitChance = 2 end   if movementRadius - target.boundingRadius <= radius /2 then hitChance = 3 end  if target.activeSpell and target.activeSpell.valid then if target.activeSpell.startTime + target.activeSpell.windup - Game.Timer() >= delay then hitChance = 4 else hitChance = 3 end end  if self:GetDistance(myHero.pos, aimPosition) >= range then hitChance = -1 end  if hitChance > 0 and checkCollision then if self:CheckMinionCollision(source, aimPosition, delay, speed, radius) then hitChance = -1 end end  return hitChance, aimPosition end  function HPred:PredictReactionTime(unit, minimumReactionTime) local reactionTime = minimumReactionTime  if unit.activeSpell and unit.activeSpell.valid then local windupRemaining = unit.activeSpell.startTime + unit.activeSpell.windup - Game.Timer() if windupRemaining > 0 then reactionTime = windupRemaining end end  local isRecalling, recallDuration = self:GetRecallingData(unit) if isRecalling and recallDuration > .25 then reactionTime = .25 end  return reactionTime end  function HPred:GetDashingTarget(source, range, delay, speed, dashThreshold, checkCollision, radius, midDash)  local target local aimPosition for i = 1, Game.HeroCount() do local t = Game.Hero(i) if t.isEnemy and t.pathing.hasMovePath and t.pathing.isDashing and t.pathing.dashSpeed>500  then local dashEndPosition = t:GetPath(1) if self:GetDistance(source, dashEndPosition) <= range  and dashEndPosition:To2D().onScreen then local dashTimeRemaining = self:GetDistance(t.pos, dashEndPosition) / t.pathing.dashSpeed local skillInterceptTime = self:GetSpellInterceptTime(myHero.pos, dashEndPosition, delay, speed) local deltaInterceptTime =skillInterceptTime - dashTimeRemaining if deltaInterceptTime > 0 and deltaInterceptTime < dashThreshold and (not checkCollision or not self:CheckMinionCollision(source, dashEndPosition, delay, speed, radius)) then target = t aimPosition = dashEndPosition return target, aimPosition end end end end end  function HPred:GetHourglassTarget(source, range, delay, speed, timingAccuracy, checkCollision, radius) local target local aimPosition for i = 1, Game.HeroCount() do local t = Game.Hero(i) if t.isEnemy and t.pos:To2D().onScreen then local success, timeRemaining = self:HasBuff(t, "zhonyasringshield") if success then local spellInterceptTime = self:GetSpellInterceptTime(myHero.pos, t.pos, delay, speed) local deltaInterceptTime = spellInterceptTime - timeRemaining if spellInterceptTime > timeRemaining and deltaInterceptTime < timingAccuracy and (not checkCollision or not self:CheckMinionCollision(source, interceptPosition, delay, speed, radius)) then target = t aimPosition = t.pos return target, aimPosition end end end end end  function HPred:GetRevivingTarget(source, range, delay, speed, timingAccuracy, checkCollision, radius) local target local aimPosition for _, revive in pairs(_cachedRevives) do if revive.isEnemy and revive.pos:To2D().onScreen then local interceptTime = self:GetSpellInterceptTime(source, revive.pos, delay, speed) if interceptTime > revive.expireTime - Game.Timer() and interceptTime - revive.expireTime - Game.Timer() < timingAccuracy then target = self:GetEnemyByName(revive.owner) aimPosition = revive.pos return target, aimPosition end end end end  function HPred:GetInstantDashTarget(source, range, delay, speed, timingAccuracy, checkCollision, radius) local target local aimPosition for i = 1, Game.HeroCount() do local t = Game.Hero(i) if t.isEnemy and t.activeSpell and t.activeSpell.valid and _blinkSpellLookupTable[t.activeSpell.name] then local windupRemaining = t.activeSpell.startTime + t.activeSpell.windup - Game.Timer() if windupRemaining > 0 then local endPos local blinkRange = _blinkSpellLookupTable[t.activeSpell.name] if type(blinkRange) == "table" then local target, distance = self:GetNearestParticleByNames(t.pos, blinkRange) if target and distance < 250 then endPos = target.pos end elseif blinkRange > 0 then endPos = Vector(t.activeSpell.placementPos.x, t.activeSpell.placementPos.y, t.activeSpell.placementPos.z) endPos = t.activeSpell.startPos + (endPos- t.activeSpell.startPos):Normalized() * math.min(self:GetDistance(t.activeSpell.startPos,endPos), range) else local blinkTarget = self:GetObjectByHandle(t.activeSpell.target) if blinkTarget then local offsetDirection  if blinkRange == 0 then offsetDirection = (blinkTarget.pos - t.pos):Normalized() elseif blinkRange == -1 then offsetDirection = (t.pos-blinkTarget.pos):Normalized() elseif blinkRange == -255 then if radius > 250 then endPos = blinkTarget.pos end end  if offsetDirection then endPos = blinkTarget.pos - offsetDirection * 150 end  end end  local interceptTime = self:GetSpellInterceptTime(myHero.pos, endPos, delay,speed) local deltaInterceptTime = interceptTime - windupRemaining if self:GetDistance(source, endPos) <= range and endPos:To2D().onScreen and deltaInterceptTime < timingAccuracy and (not checkCollision or not self:CheckMinionCollision(source, endPos, delay, speed, radius)) then target = t aimPosition = endPos return target,aimPosition end end end end end  function HPred:GetBlinkTarget(source, range, speed, delay, checkCollision, radius) local target local aimPosition for i = 1, Game.ParticleCount() do local particle = Game.Particle(i) if particle and _blinkLookupTable[particle.name] and self:GetDistance(source, particle.pos) < range and particle.pos:To2D().onScreen then local pPos = particle.pos for k,v in pairs(self:GetEnemyHeroes()) do local t = v if t and t.isEnemy and self:GetDistance(t.pos, pPos) < t.boundingRadius then if (not checkCollision or not self:CheckMinionCollision(source, pPos, delay, speed, radius)) then target = t aimPosition = pPos return target,aimPosition end end end end end end  function HPred:GetChannelingTarget(source, range, delay, speed, timingAccuracy, checkCollision, radius) local target local aimPosition for i = 1, Game.HeroCount() do local t = Game.Hero(i) local interceptTime = self:GetSpellInterceptTime(myHero.pos, t.pos, delay, speed) if self:CanTarget(t) and self:GetDistance(source, t.pos) <= range and t.pos:To2D().onScreen and self:IsChannelling(t, interceptTime) and (not checkCollision or not self:CheckMinionCollision(source, t.pos, delay, speed, radius)) then target = t aimPosition = t.pos return target, aimPosition end end end  function HPred:GetImmobileTarget(source, range, delay, speed, timingAccuracy, checkCollision, radius) local target local aimPosition for i = 1, Game.HeroCount() do local t = Game.Hero(i) if self:CanTarget(t) and self:GetDistance(source, t.pos) <= range and t.pos:To2D().onScreen then local immobileTime = self:GetImmobileTime(t)  local interceptTime = self:GetSpellInterceptTime(source, t.pos, delay, speed) if immobileTime - interceptTime > timingAccuracy and (not checkCollision or not self:CheckMinionCollision(source, t.pos, delay, speed, radius)) then target = t aimPosition = t.pos return target, aimPosition end end end end  function HPred:GetTeleportingTarget(source, range, delay, speed, timingAccuracy, checkCollision, radius) local target local aimPosition for i = 1, Game.TurretCount() do local turret = Game.Turret(i); if turret.isEnemy and self:GetDistance(source, turret.pos) <= range and turret.pos:To2D().onScreen then local hasBuff, expiresAt = self:HasBuff(turret, "teleport_target") if hasBuff then local interceptPosition = self:GetTeleportOffset(turret.pos,223.31) local deltaInterceptTime = self:GetSpellInterceptTime(source, interceptPosition, delay, speed) - expiresAt if deltaInterceptTime > 0 and deltaInterceptTime < timingAccuracy and (not checkCollision or not self:CheckMinionCollision(source, interceptPosition, delay, speed, radius)) then target = turret aimPosition =interceptPosition return target, aimPosition end end end end  for i = 1, Game.WardCount() do local ward = Game.Ward(i); if ward.isEnemy and self:GetDistance(source, ward.pos) <= range and ward.pos:To2D().onScreen then local hasBuff, expiresAt = self:HasBuff(ward, "teleport_target") if hasBuff then local interceptPosition = self:GetTeleportOffset(ward.pos,100.01) local deltaInterceptTime = self:GetSpellInterceptTime(source, interceptPosition, delay, speed) - expiresAt if deltaInterceptTime > 0 and deltaInterceptTime < timingAccuracy and (not checkCollision or not self:CheckMinionCollision(source, interceptPosition, delay, speed, radius)) then target = ward aimPosition = interceptPosition return target, aimPosition end end end end  for i = 1, Game.MinionCount() do local minion = Game.Minion(i); if minion.isEnemy and self:GetDistance(source, minion.pos) <= range and minion.pos:To2D().onScreen then local hasBuff, expiresAt = self:HasBuff(minion, "teleport_target") if hasBuff then local interceptPosition = self:GetTeleportOffset(minion.pos,143.25) local deltaInterceptTime = self:GetSpellInterceptTime(source, interceptPosition, delay, speed) - expiresAt if deltaInterceptTime > 0 and deltaInterceptTime < timingAccuracy and (not checkCollision or not self:CheckMinionCollision(source, interceptPosition, delay, speed, radius)) then target = minion aimPosition = interceptPosition return target, aimPosition end end end end end  function HPred:GetTargetMS(target) local ms = target.pathing.isDashing and target.pathing.dashSpeed or target.ms return ms end  function HPred:Angle(A, B) local deltaPos = A - B local angle = math.atan2(deltaPos.x, deltaPos.z) *  180 / math.pi if angle < 0 then angle = angle + 360 end return angle end  function HPred:UpdateMovementHistory(unit) if not _movementHistory[unit.charName] then _movementHistory[unit.charName] = {} _movementHistory[unit.charName]["EndPos"] = unit.pathing.endPos _movementHistory[unit.charName]["StartPos"] = unit.pathing.endPos _movementHistory[unit.charName]["PreviousAngle"] = 0 _movementHistory[unit.charName]["ChangedAt"] = Game.Timer() end  if _movementHistory[unit.charName]["EndPos"].x ~=unit.pathing.endPos.x or _movementHistory[unit.charName]["EndPos"].y ~=unit.pathing.endPos.y or _movementHistory[unit.charName]["EndPos"].z ~=unit.pathing.endPos.z then _movementHistory[unit.charName]["PreviousAngle"] = self:Angle(Vector(_movementHistory[unit.charName]["StartPos"].x, _movementHistory[unit.charName]["StartPos"].y, _movementHistory[unit.charName]["StartPos"].z), Vector(_movementHistory[unit.charName]["EndPos"].x, _movementHistory[unit.charName]["EndPos"].y, _movementHistory[unit.charName]["EndPos"].z)) _movementHistory[unit.charName]["EndPos"] = unit.pathing.endPos _movementHistory[unit.charName]["StartPos"] = unit.pos _movementHistory[unit.charName]["ChangedAt"] = Game.Timer() end  end  function HPred:PredictUnitPosition(unit, delay) local predictedPosition = unit.pos local timeRemaining = delay local pathNodes = self:GetPathNodes(unit) for i = 1, #pathNodes -1 do local nodeDistance = self:GetDistance(pathNodes[i], pathNodes[i +1]) local nodeTraversalTime = nodeDistance / self:GetTargetMS(unit)  if timeRemaining > nodeTraversalTime then timeRemaining =  timeRemaining - nodeTraversalTime predictedPosition = pathNodes[i + 1] else local directionVector = (pathNodes[i+1] - pathNodes[i]):Normalized() predictedPosition = pathNodes[i] + directionVector *  self:GetTargetMS(unit) * timeRemaining break; end end return predictedPosition end  function HPred:IsChannelling(target, interceptTime) if target.activeSpell and target.activeSpell.valid and target.activeSpell.isChanneling then return true end end  function HPred:HasBuff(target, buffName, minimumDuration) local duration = minimumDuration if not minimumDuration then duration = 0 end local durationRemaining for i = 1, target.buffCount do local buff = target:GetBuff(i) if buff.duration > duration and buff.name == buffName then durationRemaining = buff.duration return true, durationRemaining end end end  function HPred:GetTeleportOffset(origin, magnitude) local teleportOffset = origin + (self:GetEnemyNexusPosition()- origin):Normalized() * magnitude return teleportOffset end  function HPred:GetSpellInterceptTime(startPos, endPos, delay, speed) local interceptTime = Game.Latency()/2000 + delay + self:GetDistance(startPos, endPos) / speed return interceptTime end  function HPred:CanTarget(target) return target.isEnemy and target.alive and target.visible and target.isTargetable end  function HPred:CanTargetALL(target) return target.alive and target.visible and target.isTargetable end  function HPred:UnitMovementBounds(unit, delay, reactionTime) local startPosition = self:PredictUnitPosition(unit, delay)  local radius = 0 local deltaDelay = delay -reactionTime- self:GetImmobileTime(unit) if (deltaDelay >0) then radius = self:GetTargetMS(unit) * deltaDelay end return startPosition, radius end  function HPred:GetImmobileTime(unit) local duration = 0 for i = 0, unit.buffCount do local buff = unit:GetBuff(i); if buff.count > 0 and buff.duration> duration and (buff.type == 5 or buff.type == 8 or buff.type == 21 or buff.type == 22 or buff.type == 24 or buff.type == 11 or buff.type == 29 or buff.type == 30 or buff.type == 39 ) then duration = buff.duration end end return duration end  function HPred:GetSlowedTime(unit) local duration = 0 for i = 0, unit.buffCount do local buff = unit:GetBuff(i); if buff.count > 0 and buff.duration > duration and buff.type == 10 then duration = buff.duration return duration end end return duration end  function HPred:GetPathNodes(unit) local nodes = {} table.insert(nodes, unit.pos) if unit.pathing.hasMovePath then for i = unit.pathing.pathIndex, unit.pathing.pathCount do path = unit:GetPath(i) table.insert(nodes, path) end end return nodes end  function HPred:GetObjectByHandle(handle) local target for i = 1, Game.HeroCount() do local enemy = Game.Hero(i) if enemy.handle == handle then target = enemy return target end end  for i = 1, Game.MinionCount() do local minion = Game.Minion(i) if minion.handle == handle then target = minion return target end end  for i = 1, Game.WardCount() do local ward = Game.Ward(i); if ward.handle == handle then target = ward return target end end  for i = 1, Game.ParticleCount() do local particle = Game.Particle(i) if particle.handle == handle then target = particle return target end end end function HPred:GetObjectByPosition(position) local target for i = 1, Game.HeroCount() do local enemy = Game.Hero(i) if enemy.pos.x == position.x and enemy.pos.y == position.y and enemy.pos.z == position.z then target = enemy return target end end  for i = 1, Game.MinionCount() do local enemy = Game.Minion(i) if enemy.pos.x == position.x and enemy.pos.y == position.y and enemy.pos.z == position.z then target = enemy return target end end  for i = 1, Game.WardCount() do local enemy = Game.Ward(i); if enemy.pos.x == position.x and enemy.pos.y == position.y and enemy.pos.z == position.z then target = enemy return target end end  for i = 1, Game.ParticleCount() do local enemy = Game.Particle(i) if enemy.pos.x == position.x and enemy.pos.y == position.y and enemy.pos.z == position.z then target = enemy return target end end end  function HPred:GetEnemyHeroByHandle(handle) local target for i = 1, Game.HeroCount() do local enemy = Game.Hero(i) if enemy.handle == handle then target = enemy return target end end end  function HPred:GetNearestParticleByNames(origin, names) local target local distance = math.max for i = 1, Game.ParticleCount() do local particle = Game.Particle(i) local d = self:GetDistance(origin, particle.pos) if d < distance then distance = d target = particle end end return target, distance end  function HPred:GetPathLength(nodes) local result = 0 for i = 1, #nodes -1 do result = result + self:GetDistance(nodes[i], nodes[i + 1]) end return result end  function HPred:CheckMinionCollision(origin, endPos, delay, speed, radius, frequency)  if not frequency then frequency = radius end local directionVector = (endPos - origin):Normalized() local checkCount = self:GetDistance(origin, endPos) / frequency for i = 1, checkCount do local checkPosition = origin + directionVector * i * frequency local checkDelay = delay + self:GetDistance(origin, checkPosition) / speed if self:IsMinionIntersection(checkPosition, radius, checkDelay, radius * 3) then return true end end return false end   function HPred:IsMinionIntersection(location, radius, delay, maxDistance) if not maxDistance then maxDistance = 500 end for i = 1, Game.MinionCount() do local minion = Game.Minion(i) if self:CanTarget(minion) and self:GetDistance(minion.pos, location) < maxDistance then local predictedPosition = self:PredictUnitPosition(minion, delay) if self:GetDistance(location, predictedPosition) <= radius + minion.boundingRadius then return true end end end return false end  function HPred:VectorPointProjectionOnLineSegment(v1, v2, v) assert(v1 and v2 and v, "VectorPointProjectionOnLineSegment: wrong argument types (3 <Vector> expected)") local cx, cy, ax, ay, bx, by = v.x, (v.z or v.y), v1.x, (v1.z or v1.y), v2.x, (v2.z or v2.y) local rL = ((cx - ax) * (bx - ax) + (cy - ay) * (by - ay)) / ((bx - ax) ^ 2 + (by - ay) ^ 2) local pointLine = { x = ax + rL * (bx - ax), y = ay + rL * (by - ay) } local rS = rL < 0 and 0 or (rL > 1 and 1 or rL) local isOnSegment = rS == rL local pointSegment = isOnSegment and pointLine or { x = ax + rS * (bx - ax), y = ay + rS * (by - ay) } return pointSegment, pointLine, isOnSegment end   function HPred:GetRecallingData(unit) for K, Buff in pairs(GetBuffs(unit)) do if Buff.name == "recall" and Buff.duration > 0 then return true, Game.Timer() - Buff.startTime end end return false end  function HPred:GetEnemyByName(name) local target for i = 1, Game.HeroCount() do local enemy = Game.Hero(i) if enemy.isEnemy and enemy.charName == name then target = enemy return target end end end  function HPred:IsPointInArc(source, origin, target, angle, range) local deltaAngle = math.abs(HPred:Angle(origin, target) - HPred:Angle(source, origin)) if deltaAngle < angle and self:GetDistance(origin, target) < range then return true end end  function HPred:GetEnemyHeroes() local _EnemyHeroes = {} for i = 1, Game.HeroCount() do local enemy = Game.Hero(i) if enemy and enemy.isEnemy then table.insert(_EnemyHeroes, enemy) end end return _EnemyHeroes end  function HPred:GetDistanceSqr(p1, p2) return (p1.x - p2.x) ^ 2 + ((p1.z or p1.y) - (p2.z or p2.y)) ^ 2 end  function HPred:GetDistance(p1, p2) return math.sqrt(self:GetDistanceSqr(p1, p2)) end  local Version = "v1.00" local function Ready(spell) return myHero:GetSpellData(spell).currentCd == 0 and myHero:GetSpellData(spell).level > 0 and myHero:GetSpellData(spell).mana <= myHero.mana and Game.CanUseSpell(spell) == 0 end  local function PercentHP(target) return 100 * target.health / target.maxHealth end  local function PercentMP(target) return 100 * target.mana / target.maxMana end  local function OnScreen(unit) return unit.pos:To2D().onScreen; end  local function MinionsAround(range, pos, team) local pos = pos or myHero.pos local team = team or 300 - myHero.team local Count = 0 for i = 1, Game.MinionCount() do local minion = Game.Minion(i) if minion and minion.team == team and not minion.dead and pos:DistanceTo(minion.pos) <= range then Count = Count + 1 end end return Count end  local function HeroesAround(range, pos, team) local pos = pos or myHero.pos local team = team or 300 - myHero.team local Count = 0 for i = 1, Game.HeroCount() do local hero = Game.Hero(i) if hero and hero.team == team and not hero.dead and hero.pos:DistanceTo(pos, hero.pos) < range then Count = Count + 1 end end return Count end  local function GetDistanceSqr(Pos1, Pos2) local Pos2 = Pos2 or myHero.pos local dx = Pos1.x - Pos2.x local dz = (Pos1.z or Pos1.y) - (Pos2.z or Pos2.y) return dx^2 + dz^2 end  local function GetDistance(Pos1, Pos2) return math.sqrt(GetDistanceSqr(Pos1, Pos2)) end  local function GetDistance2D(p1,p2) local p2 = p2 or myHero return  math.sqrt(math.pow((p2.x - p1.x),2) + math.pow((p2.y - p1.y),2)) end  local function GetTarget(range) local target = nil if _G.EOWLoaded then target = EOW:GetTarget(range) elseif _G.SDK and _G.SDK.Orbwalker then target = _G.SDK.TargetSelector:GetTarget(range) else target = GOS:GetTarget(range) end return target end  local function GetMode() if _G.EOWLoaded then if EOW.CurrentMode == 1 then return "Combo" elseif EOW.CurrentMode == 2 then return "Harass" elseif EOW.CurrentMode == 3 then return "Lasthit" elseif EOW.CurrentMode == 4 then return "Clear" else return "None" end elseif _G.SDK and _G.SDK.Orbwalker then if _G.SDK.Orbwalker.Modes[_G.SDK.ORBWALKER_MODE_COMBO] then return "Combo" elseif _G.SDK.Orbwalker.Modes[_G.SDK.ORBWALKER_MODE_HARASS] then return "Harass" elseif _G.SDK.Orbwalker.Modes[_G.SDK.ORBWALKER_MODE_LANECLEAR] or _G.SDK.Orbwalker.Modes[_G.SDK.ORBWALKER_MODE_JUNGLECLEAR] then return "Clear" elseif _G.SDK.Orbwalker.Modes[_G.SDK.ORBWALKER_MODE_LASTHIT] then return "Lasthit" elseif _G.SDK.Orbwalker.Modes[_G.SDK.ORBWALKER_MODE_FLEE] then return "Flee" elseif _G.SDK.Orbwalker.Modes[_G.SDK.ORBWALKER_MODE_NONE] then return "None" end else return GOS.GetMode() end end  local function EnableOrb(bool) if _G.EOWLoaded then EOW:SetMovements(bool) EOW:SetAttacks(bool) elseif _G.SDK.Orbwalker then _G.SDK.Orbwalker:SetMovement(bool) _G.SDK.Orbwalker:SetAttack(bool) else GOS.BlockMovement = not bool GOS.BlockAttack = not bool end end  local function HasBuff(unit, buffname) for i = 0, unit.buffCount do local buff = unit:GetBuff(i) if buff.name == buffname and buff.count > 0 then return true end end return false end  local HKITEM = { [ITEM_1] = HK_ITEM_1, [ITEM_2] = HK_ITEM_2, [ITEM_3] = HK_ITEM_3, [ITEM_4] = HK_ITEM_4, [ITEM_5] = HK_ITEM_5, [ITEM_6] = HK_ITEM_6, [ITEM_7] = HK_ITEM_7, }  local function NoPotion() for i = 0, myHero.buffCount do local buff = myHero:GetBuff(i) if buff.type == 13 and Game.Timer() < buff.expireTime then return false end end return true end  local function isOnScreen(obj) return obj.pos:To2D().onScreen; end  local function IsEvading() if ExtLibEvade and ExtLibEvade.Evading then return true end return false end  local function IsAttacking() if myHero.attackData and myHero.attackData.target and myHero.attackData.state == STATE_WINDUP then return true end return false end  local function IsRecalling() for K, Buff in pairs(GetBuffs(myHero)) do if Buff.name == "recall" and Buff.duration > 0 then return true end end return false end  class "DrMundo"  local DrMundoVersion = "v1.00"  function DrMundo:__init() self:LoadSpells() self:LoadMenu() Callback.Add("Tick", function() self:Tick() end) Callback.Add("Draw", function() self:Draw() end) end  function DrMundo:LoadSpells() Q = { Range = 975, Delay = 0.25, cost = 0, Speed = 1850, Width = 60, Collision = true, icon = "https://vignette.wikia.nocookie.net/leagueoflegends/images/f/f2/Infected_Cleaver.png" } W = { Range = 250, Delay = 0.25, cost = 0, icon = "https://vignette.wikia.nocookie.net/leagueoflegends/images/5/5d/Burning_Agony.png" } E = { Range = 150, Delay = 0.25, cost = 0, icon = "https://vignette.wikia.nocookie.net/leagueoflegends/images/9/95/Masochism.png" } R = { Range = 600, Delay = 0.25, cost = 0, icon = "https://vignette.wikia.nocookie.net/leagueoflegends/images/8/81/Sadism.png" } end  function DrMundo:LoadMenu() RomanovDrMundo = MenuElement({type = MENU, id = "RomanovDrMundo", name = "Monsters Dr. Mundo "..Version}) RomanovDrMundo:MenuElement({name = "Dr. Mundo", drop = {DrMundoVersion}, leftIcon = "https://vignette.wikia.nocookie.net/leagueoflegends/images/4/47/Dr._Mundo_OriginalCircle.png"}) RomanovDrMundo:MenuElement({type = MENU, id = "Combo", name = "Combo"}) RomanovDrMundo.Combo:MenuElement({id = "Q", name = "Q", value = true, leftIcon = Q.icon}) RomanovDrMundo.Combo:MenuElement({id = "W", name = "W", value = true, leftIcon = W.icon}) RomanovDrMundo.Combo:MenuElement({id = "E", name = "E", value = true, leftIcon = E.icon}) RomanovDrMundo.Combo:MenuElement({id = "R", name = "R", value = true, leftIcon = R.icon}) RomanovDrMundo.Combo:MenuElement({id = "HP", name = "Max health", value = 15, min = 0, max = 100}) RomanovDrMundo.Combo:MenuElement({id = "Enemies", name = "Min enemies", value = 1, min = 1, max = 5}) RomanovDrMundo:MenuElement({type = MENU, id = "Clear", name = "Clear"}) RomanovDrMundo.Clear:MenuElement({id = "Key", name = "Enabled", key = string.byte("A"), toggle = true}) RomanovDrMundo.Clear:MenuElement({id = "Q", name = "Q", value = true, leftIcon = Q.icon}) RomanovDrMundo.Clear:MenuElement({id = "W", name = "W", value = true, leftIcon = W.icon}) RomanovDrMundo.Clear:MenuElement({id = "Whit", name = "W min minions", value = 5, min = 1, max = 7}) RomanovDrMundo.Clear:MenuElement({id = "HP", name = "Min health", value = 45, min = 0, max = 100}) RomanovDrMundo:MenuElement({type = MENU, id = "Harass", name = "Harass"}) RomanovDrMundo.Harass:MenuElement({id = "Key", name = "Enabled", key = string.byte("S"), toggle = true}) RomanovDrMundo.Harass:MenuElement({id = "Q", name = "Q", value = true, leftIcon = Q.icon}) RomanovDrMundo.Harass:MenuElement({id = "W", name = "W", value = true, leftIcon = W.icon}) RomanovDrMundo.Harass:MenuElement({id = "E", name = "E", value = true, leftIcon = E.icon}) RomanovDrMundo.Harass:MenuElement({id = "AutoQ", name = "Q auto harass", value = true}) RomanovDrMundo:MenuElement({type = MENU, id = "Ultimate", name = "Ultimate"}) RomanovDrMundo.Ultimate:MenuElement({id = "R", name = "R", value = true, leftIcon = R.icon}) RomanovDrMundo.Ultimate:MenuElement({id = "HP", name = "Max health", value = 15, min = 0, max = 100}) RomanovDrMundo.Ultimate:MenuElement({id = "Enemies", name = "Min enemies", value = 2, min = 1, max = 5}) RomanovDrMundo:MenuElement({type = MENU, id = "Flee", name = "Flee"}) RomanovDrMundo.Flee:MenuElement({id = "Q", name = "Q", value = true, leftIcon = Q.icon}) RomanovDrMundo:MenuElement({type = MENU, id = "Killsteal", name = "Killsteal"}) RomanovDrMundo.Killsteal:MenuElement({id = "Q", name = "Q", value = true, leftIcon = Q.icon}) RomanovDrMundo:MenuElement({type = MENU, id = "Draw", name = "Drawings"}) RomanovDrMundo.Draw:MenuElement({id = "Q", name = "Q range", value = true, leftIcon = Q.icon}) RomanovDrMundo.Draw:MenuElement({id = "W", name = "W range", value = true, leftIcon = W.icon}) RomanovDrMundo.Draw:MenuElement({id = "CT", name = "Clear on/off", value = true}) RomanovDrMundo.Draw:MenuElement({id = "HT", name = "Harass on/off", value = true}) end  function DrMundo:Tick() if myHero.dead or Game.IsChatOpen() or IsRecalling() or IsEvading() then return end local Mode = GetMode() if Mode == "Combo" then self:Combo() elseif Mode == "Clear" then self:Clear() elseif Mode == "Harass" then self:Harass() elseif Mode == "Flee" then self:Flee() end if RomanovDrMundo.Harass.AutoQ:Value() then self:AutoQ() end if Ready(_R) then self:Ultimate() end if (Mode == "None" or (HeroesAround(W.Range + 100) == 0 and MinionsAround(W.Range + 100) == 0 and MinionsAround(W.Range + 100, myHero.pos, 300) == 0)) and Ready(_W) and myHero:GetSpellData(_W).toggleState ~= 1 then Control.CastSpell(HK_W) end self:Killsteal() end  function DrMundo:Ultimate() if HeroesAround(R.Range) >= RomanovDrMundo.Ultimate.Enemies:Value() and PercentHP(myHero) <= RomanovDrMundo.Ultimate.HP:Value() then Control.CastSpell(HK_R) end end  function DrMundo:Combo() local target = GetTarget(Q.Range)  if target == nil then return end if RomanovDrMundo.Combo.R:Value() and Ready(_R) then if HeroesAround(R.Range) >= RomanovDrMundo.Combo.Enemies:Value() and PercentHP(myHero) <= RomanovDrMundo.Combo.HP:Value() then Control.CastSpell(HK_R) end end if RomanovDrMundo.Combo.E:Value() and Ready(_E) and (GetDistance(target.pos) < myHero.range + 50 or myHero.attackData.state == STATE_WINDDOWN) then Control.CastSpell(HK_E) end if RomanovDrMundo.Combo.W:Value() and Ready(_W) and GetDistance(target.pos) < W.Range and myHero:GetSpellData(_W).toggleState == 1 then Control.CastSpell(HK_W) end if RomanovDrMundo.Combo.Q:Value() and Ready(_Q) and GetDistance(target.pos) < Q.Range then if HPred:CanTarget(target) then local hitChance, aimPosition = HPred:GetHitchance(myHero.pos, target, Q.Range, Q.Delay, Q.Speed, Q.Width, Q.Collision, nil) if hitChance and hitChance >= 2 and HPred:GetDistance(myHero.pos, aimPosition) <= Q.Range then Control.CastSpell(HK_Q, aimPosition) end end end end  function DrMundo:AutoQ() local target = GetTarget(Q.Range) if RomanovDrMundo.Harass.Key:Value() == false then return end  if target == nil then return end if RomanovDrMundo.Harass.Q:Value() and Ready(_Q) and GetDistance(target.pos) < Q.Range then if HPred:CanTarget(target) then local hitChance, aimPosition = HPred:GetHitchance(myHero.pos, target, Q.Range, Q.Delay, Q.Speed, Q.Width, Q.Collision, nil) if hitChance and hitChance >= 2 and HPred:GetDistance(myHero.pos, aimPosition) <= Q.Range then Control.CastSpell(HK_Q, aimPosition) end end end end  function DrMundo:Harass() local target = GetTarget(Q.Range) if RomanovDrMundo.Harass.Key:Value() == false then return end  if RomanovDrMundo.Harass.E:Value() and Ready(_E) and (GetDistance(target.pos) < 250 or myHero.attackData.state == STATE_WINDDOWN) then Control.CastSpell(HK_E) end if RomanovDrMundo.Harass.W:Value() and Ready(_W) and GetDistance(target.pos) < W.Range and myHero:GetSpellData(_W).toggleState == 1 then Control.CastSpell(HK_W) end if RomanovDrMundo.Harass.Q:Value() and Ready(_Q) and GetDistance(target.pos) < Q.Range then if HPred:CanTarget(target) then local hitChance, aimPosition = HPred:GetHitchance(myHero.pos, target, Q.Range, Q.Delay, Q.Speed, Q.Width, Q.Collision, nil) if hitChance and hitChance >= 2 and HPred:GetDistance(myHero.pos, aimPosition) <= Q.Range then Control.CastSpell(HK_Q, aimPosition) end end end end  function DrMundo:Clear() if RomanovDrMundo.Clear.Key:Value() == false then return end if PercentHP(myHero) < RomanovDrMundo.Clear.HP:Value() then return end  for i = 1, Game.MinionCount() do local minion = Game.Minion(i) if minion and minion.team == 300 - myHero.team then if RomanovDrMundo.Clear.Q:Value() and Ready(_Q) and GetDistance(minion.pos) < Q.Range then local pred = minion:GetPrediction(Q.Speed, Q.Delay) if GetDistance(pred) < Q.Range then Control.CastSpell(HK_Q, pred) end end if RomanovDrMundo.Clear.W:Value() and Ready(_W) and MinionsAround(W.Range) >= RomanovDrMundo.Clear.Whit:Value() then if myHero:GetSpellData(_W).toggleState == 1 then Control.CastSpell(HK_W) end end elseif minion and minion.team == 300 then if RomanovDrMundo.Clear.W:Value() and Ready(_W) and GetDistance(minion.pos) < W.Range and myHero:GetSpellData(_W).toggleState == 1 then Control.CastSpell(HK_W) end if RomanovDrMundo.Clear.Q:Value() and Ready(_Q) and GetDistance(minion.pos) < Q.Range then local pred = minion:GetPrediction(Q.Speed, Q.Delay) if GetDistance(pred) < Q.Range then Control.CastSpell(HK_Q, pred) end end end end end  function DrMundo:Flee() local target = GetTarget(Q.Range)  if target and RomanovDrMundo.Flee.Q:Value() and Ready(_Q) then if HPred:CanTarget(target) then local hitChance, aimPosition = HPred:GetHitchance(myHero.pos, target, Q.Range, Q.Delay, Q.Speed, Q.Width, Q.Collision, nil) if hitChance and hitChance >= 2 and HPred:GetDistance(myHero.pos, aimPosition) <= Q.Range then Control.CastSpell(HK_Q, aimPosition) end end end end  function DrMundo:Killsteal() local target = GetTarget(Q.Range) if target == nil then return end  if RomanovDrMundo.Killsteal.Q:Value() and Ready(_Q) then local Qdmg = 30 + 50 * myHero:GetSpellData(_Q).level if Qdmg > target.health then if HPred:CanTarget(target) then local hitChance, aimPosition = HPred:GetHitchance(myHero.pos, target, Q.Range, Q.Delay, Q.Speed, Q.Width, Q.Collision, nil) if hitChance and hitChance >= 2 and HPred:GetDistance(myHero.pos, aimPosition) <= Q.Range then Control.CastSpell(HK_Q, aimPosition) end end end end end  function DrMundo:Draw() if RomanovDrMundo.Draw.Q:Value() and Ready(_Q) then Draw.Circle(myHero.pos, Q.Range, 3,  Draw.Color(255,255, 075, 180)) end if RomanovDrMundo.Draw.W:Value() and Ready(_W) then Draw.Circle(myHero.pos, W.Range, 3,  Draw.Color(255,000, 075, 180)) end if RomanovDrMundo.Draw.CT:Value() then local textPos = myHero.pos:To2D() if RomanovDrMundo.Clear.Key:Value() then Draw.Text("Clear On", 20, textPos.x - 33, textPos.y + 60, Draw.Color(255, 000, 255, 000)) else Draw.Text("Clear Off", 20, textPos.x - 33, textPos.y + 60, Draw.Color(255, 225, 000, 000)) end end if RomanovDrMundo.Draw.HT:Value() then local textPos = myHero.pos:To2D() if RomanovDrMundo.Harass.Key:Value() then Draw.Text("Harass On", 20, textPos.x - 40, textPos.y + 80, Draw.Color(255, 000, 255, 000)) else Draw.Text("Harass Off", 20, textPos.x - 40, textPos.y + 80, Draw.Color(255, 255, 000, 000)) end end end class "Utility"  local UtilityVersion = "v1.00"  function Utility:__init() self:Menu() Callback.Add("Tick", function() self:Tick() end) end  function Utility:Menu() Romanov = MenuElement({type = MENU, id = "Romanov", name = "Monsters Utility v1.00"})  Romanov:MenuElement({type = MENU, id = "LevelerMundo", name = "Auto Leveler"}) Romanov.LevelerMundo:MenuElement({id = "Enabled", name = "Enabled", value = true}) Romanov.LevelerMundo:MenuElement({id = "Block", name = "Block on Level 1", value = true}) Romanov.LevelerMundo:MenuElement({id = "Order", name = "Skill Priority", value = 2, drop = {"[Q] - [W] - [E] > Max [Q]","[Q] - [E] - [W] > Max [Q]","[W] - [Q] - [E] > Max [W]","[W] - [E] - [Q] > Max [W]","[E] - [Q] - [W] > Max [E]","[E] - [W] - [Q] > Max [E]"}})  Romanov:MenuElement({type = MENU, id = "Activator", name = "Activator"}) Romanov.Activator:MenuElement({type = MENU, id = "CS", name = "Cleanse"}) Romanov.Activator.CS:MenuElement({id = "Blind", name = "Blind", value = false}) Romanov.Activator.CS:MenuElement({id = "Charm", name = "Charm", value = true}) Romanov.Activator.CS:MenuElement({id = "Flee", name = "Flee", value = true}) Romanov.Activator.CS:MenuElement({id = "Slow", name = "Slow", value = false}) Romanov.Activator.CS:MenuElement({id = "Root", name = "Root/Snare", value = true}) Romanov.Activator.CS:MenuElement({id = "Poly", name = "Polymorph", value = true}) Romanov.Activator.CS:MenuElement({id = "Silence", name = "Silence", value = true}) Romanov.Activator.CS:MenuElement({id = "Stun", name = "Stun", value = true}) Romanov.Activator.CS:MenuElement({id = "Taunt", name = "Taunt", value = true}) Romanov.Activator:MenuElement({type = MENU, id = "P", name = "Potions"}) Romanov.Activator.P:MenuElement({id = "Pot", name = "All Potions", value = true}) Romanov.Activator.P:MenuElement({id = "HP", name = "Health % to Potion", value = 60, min = 0, max = 100}) Romanov.Activator:MenuElement({type = MENU, id = "I", name = "Items"}) Romanov.Activator.I:MenuElement({id = "O", name = "Offensive Items", type = MENU}) Romanov.Activator.I.O:MenuElement({id = "Bilge", name = "Bilgewater Cutlass (all)", value = true}) Romanov.Activator.I.O:MenuElement({id = "Edge", name = "Edge of the Night", value = true}) Romanov.Activator.I.O:MenuElement({id = "Frost", name = "Frost Queen's Claim", value = true}) Romanov.Activator.I.O:MenuElement({id = "Proto", name = "Hextec Revolver (all)", value = true}) Romanov.Activator.I.O:MenuElement({id = "Ohm", name = "Ohmwrecker", value = true}) Romanov.Activator.I.O:MenuElement({id = "Glory", name = "Righteous Glory", value = true}) Romanov.Activator.I.O:MenuElement({id = "Tiamat", name = "Tiamat (all)", value = true}) Romanov.Activator.I.O:MenuElement({id = "YG", name = "Youmuu's Ghostblade", value = true}) Romanov.Activator.I:MenuElement({id = "D", name = "Defensive Items", type = MENU}) Romanov.Activator.I.D:MenuElement({id = "Face", name = "Face of the Mountain", value = true}) Romanov.Activator.I.D:MenuElement({id = "Garg", name = "Gargoyle Stoneplate", value = true}) Romanov.Activator.I.D:MenuElement({id = "Locket", name = "Locket of the Iron Solari", value = true}) Romanov.Activator.I.D:MenuElement({id = "MC", name = "Mikael's Crucible", value = true}) Romanov.Activator.I.D:MenuElement({id = "QSS", name = "Quicksilver Sash", value = true}) Romanov.Activator.I.D:MenuElement({id = "RO", name = "Randuin's Omen", value = true}) Romanov.Activator.I.D:MenuElement({id = "SE", name = "Seraph's Embrace", value = true}) Romanov.Activator.I:MenuElement({id = "U", name = "Utility Items", type = MENU}) Romanov.Activator.I.U:MenuElement({id = "Ban", name = "Banner of Command", value = true}) Romanov.Activator.I.U:MenuElement({id = "Red", name = "Redemption", value = true}) Romanov.Activator.I.U:MenuElement({id = "TA", name = "Talisman of Ascension", value = true}) Romanov.Activator.I.U:MenuElement({id = "ZZ", name = "Zz'Rot Portal", value = true})  Romanov.Activator:MenuElement({type = MENU, id = "S", name = "Summoner Spells"}) if myHero:GetSpellData(SUMMONER_1).name == "SummonerSmite" or myHero:GetSpellData(SUMMONER_1).name == "S5_SummonerSmitePlayerGanker" or myHero:GetSpellData(SUMMONER_1).name == "S5_SummonerSmiteDuel" or myHero:GetSpellData(SUMMONER_2).name == "SummonerSmite" or myHero:GetSpellData(SUMMONER_2).name == "S5_SummonerSmitePlayerGanker" or myHero:GetSpellData(SUMMONER_1).name == "S5_SummonerSmiteDuel" then Romanov.Activator.S:MenuElement({id = "Smite", name = "Combo Smite", value = true}) Romanov.Activator.S:MenuElement({id = "SmiteS", name = "Smite Stacks to Combo", value = 1, min = 1, max = 2}) end if myHero:GetSpellData(SUMMONER_1).name == "SummonerHeal" or myHero:GetSpellData(SUMMONER_2).name == "SummonerHeal" then Romanov.Activator.S:MenuElement({id = "Heal", name = "Heal", value = true}) Romanov.Activator.S:MenuElement({id = "HealHP", name = "HP Under %", value = 25, min = 0, max = 100}) end if myHero:GetSpellData(SUMMONER_1).name == "SummonerBarrier" or myHero:GetSpellData(SUMMONER_2).name == "SummonerBarrier" then Romanov.Activator.S:MenuElement({id = "Barrier", name = "Barrier", value = true}) Romanov.Activator.S:MenuElement({id = "BarrierHP", name = "HP Under %", value = 25, min = 0, max = 100}) end if myHero:GetSpellData(SUMMONER_1).name == "SummonerDot" or myHero:GetSpellData(SUMMONER_2).name == "SummonerDot" then Romanov.Activator.S:MenuElement({id = "Ignite", name = "Combo Ignite", value = true}) end if myHero:GetSpellData(SUMMONER_1).name == "SummonerExhaust" or myHero:GetSpellData(SUMMONER_2).name == "SummonerExhaust" then Romanov.Activator.S:MenuElement({id = "Exh", name = "Combo Exhaust", value = true}) end if myHero:GetSpellData(SUMMONER_1).name == "SummonerBoost" or myHero:GetSpellData(SUMMONER_2).name == "SummonerBoost" then Romanov.Activator.S:MenuElement({id = "Cleanse", name = "Cleanse", value = true}) end end  function Utility:Tick() self:AutoLevel() self:Activator() end  function Utility:AutoLevel() if Romanov.LevelerMundo.Enabled:Value() == false then return end local Sequence = { [1] = { HK_Q, HK_W, HK_E, HK_Q, HK_Q, HK_R, HK_Q, HK_W, HK_Q, HK_W, HK_R, HK_W, HK_W, HK_E, HK_E, HK_R, HK_E, HK_E }, [2] = { HK_Q, HK_E, HK_W, HK_Q, HK_Q, HK_R, HK_Q, HK_E, HK_Q, HK_E, HK_R, HK_E, HK_E, HK_W, HK_W, HK_R, HK_W, HK_W }, [3] = { HK_W, HK_Q, HK_E, HK_W, HK_W, HK_R, HK_W, HK_Q, HK_W, HK_Q, HK_R, HK_Q, HK_Q, HK_E, HK_E, HK_R, HK_E, HK_E }, [4] = { HK_W, HK_E, HK_Q, HK_W, HK_W, HK_R, HK_W, HK_E, HK_W, HK_E, HK_R, HK_E, HK_E, HK_Q, HK_Q, HK_R, HK_Q, HK_Q }, [5] = { HK_E, HK_Q, HK_W, HK_E, HK_E, HK_R, HK_E, HK_Q, HK_E, HK_Q, HK_R, HK_Q, HK_Q, HK_W, HK_W, HK_R, HK_W, HK_W }, [6] = { HK_E, HK_W, HK_Q, HK_E, HK_E, HK_R, HK_E, HK_W, HK_E, HK_W, HK_R, HK_W, HK_W, HK_Q, HK_Q, HK_R, HK_Q, HK_Q }, } local Slot = nil local Tick = 0 local SkillPoints = myHero.levelData.lvlPts local level = myHero.levelData.lvl local Check = Sequence[Romanov.LevelerMundo.Order:Value()][level - SkillPoints + 1] if SkillPoints > 0 then if Romanov.LevelerMundo.Block:Value() and level == 1 then return end if GetTickCount() - Tick > 800 and Check ~= nil then Control.KeyDown(HK_LUS) Control.KeyDown(Check) Slot = Check Tick = GetTickCount() end end if Control.IsKeyDown(HK_LUS) then Control.KeyUp(HK_LUS) end if Slot and Control.IsKeyDown(Slot) then Control.KeyUp(Slot) end end  function Utility:Activator() local target = GetTarget(1575) if target == nil then return end local items = {} for slot = ITEM_1,ITEM_6 do local id = myHero:GetItemData(slot).itemID if id > 0 then items[id] = slot end end local Banner = items[3060] if Banner and myHero:GetSpellData(Banner).currentCd == 0 and Romanov.Activator.I.U.Ban:Value() then for i = 1, Game.MinionCount() do local minion = Game.Minion(i) if minion and minion.team == myHero.team and myHero.pos:DistanceTo(minion.pos) < 1200 then Control.CastSpell(HKITEM[Banner], minion) end end end local Potion = items[2003] or items[2010] or items[2031] or items[2032] or items[2033] if Potion and target and myHero:GetSpellData(Potion).currentCd == 0 and Romanov.Activator.P.Pot:Value() and PercentHP(myHero) < Romanov.Activator.P.HP:Value() and NoPotion() then Control.CastSpell(HKITEM[Potion]) end local Face = items[3401] if Face and target and myHero:GetSpellData(Face).currentCd == 0 and Romanov.Activator.D.Face:Value() and PercentHP(myHero) < 30 then Control.CastSpell(HKITEM[Face]) end local Garg = items[3193] if Garg and target and myHero:GetSpellData(Garg).currentCd == 0 and Romanov.Activator.D.Garg:Value() and PercentHP(myHero) < 30 then Control.CastSpell(HKITEM[Garg]) end local Red = items[3107] if Red and target and myHero:GetSpellData(Red).currentCd == 0 and Romanov.Activator.U.Red:Value() and PercentHP(myHero) < 30 then Control.CastSpell(HKITEM[Red], myHero.pos) end local SE = items[3048] if SE and target and myHero:GetSpellData(SE).currentCd == 0 and Romanov.Activator.D.SE:Value() and PercentHP(myHero) < 30 and MP(myHero) > 45 then Control.CastSpell(HKITEM[SE]) end local Locket = items[3190] if Locket and target and myHero:GetSpellData(Locket).currentCd == 0 and Romanov.Activator.D.Locket:Value() and PercentHP(myHero) < 30 then Control.CastSpell(HKITEM[Locket]) end local ZZ = items[3144] or items[3153] if ZZ and myHero:GetSpellData(ZZ).currentCd == 0 and Romanov.Activator.I.U.ZZ:Value() then for i = 1, Game.TurretCount() do local turret = Game.Turret(i) if turret and turret.isAlly and PercentHP(turret) < 100 and myHero.pos:DistanceTo(turret.pos) < 400 then Control.CastSpell(HKITEM[ZZ], turret.pos) end end end if myHero:GetSpellData(SUMMONER_1).name == "SummonerHeal" or myHero:GetSpellData(SUMMONER_2).name == "SummonerHeal" then if Romanov.Activator.S.Heal:Value() and target then if myHero:GetSpellData(SUMMONER_1).name == "SummonerHeal" and Ready(SUMMONER_1) and PercentHP(myHero) < Romanov.Activator.S.HealHP:Value() then Control.CastSpell(HK_SUMMONER_1) elseif myHero:GetSpellData(SUMMONER_2).name == "SummonerHeal" and Ready(SUMMONER_2) and PercentHP(myHero) < Romanov.Activator.S.HealHP:Value() then Control.CastSpell(HK_SUMMONER_2) end end end if myHero:GetSpellData(SUMMONER_1).name == "SummonerBarrier" or myHero:GetSpellData(SUMMONER_2).name == "SummonerBarrier" then if Romanov.Activator.S.Barrier:Value() and target then if myHero:GetSpellData(SUMMONER_1).name == "SummonerBarrier" and Ready(SUMMONER_1) and PercentHP(myHero) < Romanov.Activator.S.BarrierHP:Value() then Control.CastSpell(HK_SUMMONER_1) elseif myHero:GetSpellData(SUMMONER_2).name == "SummonerBarrier" and Ready(SUMMONER_2) and PercentHP(myHero) < Romanov.Activator.S.BarrierHP:Value() then Control.CastSpell(HK_SUMMONER_2) end end end if myHero:GetSpellData(SUMMONER_1).name == "SummonerBoost" or myHero:GetSpellData(SUMMONER_2).name == "SummonerBoost" then if target then for i = 0, myHero.buffCount do local buff = myHero:GetBuff(i); if buff.count > 0 then if ((buff.type == 5 and Romanov.Activator.CS.Stun:Value()) or (buff.type == 7 and  Romanov.Activator.CS.Silence:Value()) or (buff.type == 8 and  Romanov.Activator.CS.Taunt:Value()) or (buff.type == 9 and  Romanov.Activator.CS.Poly:Value()) or (buff.type == 10 and  Romanov.Activator.CS.Slow:Value()) or (buff.type == 11 and  Romanov.Activator.CS.Root:Value()) or (buff.type == 21 and  Romanov.Activator.CS.Flee:Value()) or (buff.type == 22 and  Romanov.Activator.CS.Charm:Value()) or (buff.type == 25 and  Romanov.Activator.CS.Blind:Value()) or (buff.type == 28 and  Romanov.Activator.CS.Flee:Value())) then if myHero:GetSpellData(SUMMONER_1).name == "SummonerBoost" and Ready(SUMMONER_1) and Romanov.Activator.S.Cleanse:Value() then Control.CastSpell(HK_SUMMONER_1) elseif myHero:GetSpellData(SUMMONER_2).name == "SummonerBoost" and Ready(SUMMONER_2) and Romanov.Activator.S.Cleanse:Value() then Control.CastSpell(HK_SUMMONER_2) end local MC = items[3222] if MC and myHero:GetSpellData(MC).currentCd == 0 and Romanov.Activator.I.D.MC:Value() and myHero.pos:DistanceTo(target.pos) < 1200 then Control.CastSpell(HKITEM[MC]) end local QSS = items[3140] or items[3139] if QSS and myHero:GetSpellData(QSS).currentCd == 0 and Romanov.Activator.I.D.QSS:Value() and myHero.pos:DistanceTo(target.pos) < 1200 then Control.CastSpell(HKITEM[QSS]) end end end end end end if GetMode() == "Combo" then local Bilge = items[3144] or items[3153] if Bilge and myHero:GetSpellData(Bilge).currentCd == 0 and Romanov.Activator.I.O.Bilge:Value() and myHero.pos:DistanceTo(target.pos) < 550 then Control.CastSpell(HKITEM[Bilge], target.pos) end local Edge = items[3144] or items[3153] if Edge and myHero:GetSpellData(Edge).currentCd == 0 and Romanov.Activator.I.O.Edge:Value() and myHero.pos:DistanceTo(target.pos) < 1200 then Control.CastSpell(HKITEM[Edge]) end local Frost = items[3092] if Frost and myHero:GetSpellData(Frost).currentCd == 0 and Romanov.Activator.I.O.Frost:Value() and myHero.pos:DistanceTo(target.pos) < 1575 then Control.CastSpell(HKITEM[Frost]) end local Randuin = items[3143] if Randuin and myHero:GetSpellData(Randuin).currentCd == 0 and Romanov.Activator.I.D.RO:Value() and myHero.pos:DistanceTo(target.pos) < 500 then Control.CastSpell(HKITEM[Randuin]) end local Hex = items[3152] or items[3146] or items[3030] if Hex and myHero:GetSpellData(Hex).currentCd == 0 and Romanov.Activator.I.O.Proto:Value() and myHero.pos:DistanceTo(target.pos) > 550 then Control.CastSpell(HKITEM[Hex], target.pos) end local Pistol = items[3146] if Pistol and myHero:GetSpellData(Pistol).currentCd == 0 and Romanov.Activator.I.O.Proto:Value() and myHero.pos:DistanceTo(target.pos) < 700 then Control.CastSpell(HKITEM[Pistol], target.pos) end local Ohm = items[3144] or items[3153] if Ohm and myHero:GetSpellData(Ohm).currentCd == 0 and Romanov.Activator.I.O.Ohm:Value() and myHero.pos:DistanceTo(target.pos) < 800 then for i = 1, Game.TurretCount() do local turret = Game.Turret(i) if turret and turret.isEnemy and turret.isTargetableToTeam and myHero.pos:DistanceTo(turret.pos) < 775 then Control.CastSpell(HKITEM[Ohm]) end end end local Glory = items[3800] if Glory and myHero:GetSpellData(Glory).currentCd == 0 and Romanov.Activator.I.O.Glory:Value() and myHero.pos:DistanceTo(target.pos) < 1575 then Control.CastSpell(HKITEM[Glory]) end local Tiamat = items[3077] or items[3748] or items[3074] if Tiamat and myHero:GetSpellData(Tiamat).currentCd == 0 and Romanov.Activator.I.O.Tiamat:Value() and myHero.pos:DistanceTo(target.pos) < 400 and myHero.attackData.state == 2 then Control.CastSpell(HKITEM[Tiamat], target.pos) end local YG = items[3142] if YG and myHero:GetSpellData(YG).currentCd == 0 and Romanov.Activator.I.O.YG:Value() and myHero.pos:DistanceTo(target.pos) < 1575 then Control.CastSpell(HKITEM[YG]) end local TA = items[3069] if TA and myHero:GetSpellData(TA).currentCd == 0 and Romanov.Activator.I.D.TA:Value() and myHero.pos:DistanceTo(target.pos) < 1575 then Control.CastSpell(HKITEM[TA]) end if myHero:GetSpellData(SUMMONER_1).name == "SummonerSmite" or myHero:GetSpellData(SUMMONER_1).name == "S5_SummonerSmitePlayerGanker" or myHero:GetSpellData(SUMMONER_1).name == "S5_SummonerSmiteDuel" or myHero:GetSpellData(SUMMONER_2).name == "SummonerSmite" or myHero:GetSpellData(SUMMONER_2).name == "S5_SummonerSmitePlayerGanker" or myHero:GetSpellData(SUMMONER_1).name == "S5_SummonerSmiteDuel" then if Romanov.Activator.S.Smite:Value() then if myHero:GetSpellData(SUMMONER_1).name == "S5_SummonerSmiteDuel" and Ready(SUMMONER_1) and myHero:GetSpellData(SUMMONER_1).ammo >= Romanov.Activator.S.SmiteS:Value() and myHero.pos:DistanceTo(target.pos) < 500 then Control.CastSpell(HK_SUMMONER_1, target) elseif myHero:GetSpellData(SUMMONER_2).name == "S5_SummonerSmiteDuel" and Ready(SUMMONER_2) and myHero:GetSpellData(SUMMONER_2).ammo >= Romanov.Activator.S.SmiteS:Value() and myHero.pos:DistanceTo(target.pos) < 500 then Control.CastSpell(HK_SUMMONER_2, target) end if myHero:GetSpellData(SUMMONER_1).name == "S5_SummonerSmitePlayerGanker" and Ready(SUMMONER_1) and myHero:GetSpellData(SUMMONER_1).ammo >= Romanov.Activator.S.SmiteS:Value() and myHero.pos:DistanceTo(target.pos) < 500 then Control.CastSpell(HK_SUMMONER_1, target) elseif myHero:GetSpellData(SUMMONER_2).name == "S5_SummonerSmitePlayerGanker" and Ready(SUMMONER_2) and myHero:GetSpellData(SUMMONER_2).ammo >= Romanov.Activator.S.SmiteS:Value() and myHero.pos:DistanceTo(target.pos) < 500 then Control.CastSpell(HK_SUMMONER_2, target) end end end if myHero:GetSpellData(SUMMONER_1).name == "SummonerDot" or myHero:GetSpellData(SUMMONER_2).name == "SummonerDot" then if Romanov.Activator.S.Ignite:Value() then local IgDamage = 70 + 20 * myHero.levelData.lvl if myHero:GetSpellData(SUMMONER_1).name == "SummonerDot" and Ready(SUMMONER_1) and IgDamage > target.health and myHero.pos:DistanceTo(target.pos) < 600 then Control.CastSpell(HK_SUMMONER_1, target) elseif myHero:GetSpellData(SUMMONER_2).name == "SummonerDot" and Ready(SUMMONER_2) and IgDamage > target.health and myHero.pos:DistanceTo(target.pos) < 600 then Control.CastSpell(HK_SUMMONER_2, target) end end end end end  Callback.Add("Load", function() if myHero.charName == "DrMundo" then DrMundo() Utility() else return end end)
